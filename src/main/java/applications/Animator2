package maze;

import graph.ShortestPath;
import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;
import graph.ShortestPath.Distances;
import adaptator.GraphMaze;

public class MazeAnimator<C> extends JFrame implements ShortestPath.Animator<C> {
    private final Map<C, JPanel> cellPanels;
    private final JPanel grid;
    private final int cellSize = 20;
    private final int rows = 10; // À ajuster selon Maze
    private final int cols = 10;

    public MazeAnimator() {
        cellPanels = new HashMap<>();
        setTitle("Maze Animation");
        grid = new JPanel(new GridLayout(rows, cols));
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                JPanel cell = new JPanel();
                cell.setBackground(Color.WHITE);
                grid.add(cell);
                cellPanels.put((C) ("cell" + i + "," + j), cell); // À adapter
            }
        }
        add(grid);
        setSize(cols * cellSize, rows * cellSize);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setVisible(true);
    }

    @Override
    public void accept(C cell, int dist) {
        JPanel panel = cellPanels.get(cell);
        if (panel != null) {
            panel.setBackground(Color.BLUE);
            panel.repaint();
            try {
                Thread.sleep(100); // Pause pour l'animation
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public void animateMaze(Maze<C> maze, ShortestPath<C> dijkstra) {
        Distances<C> result = dijkstra.compute(new GraphMaze<>(maze), maze.getStart(), this);
    }

}
