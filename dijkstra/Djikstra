package dijkstra;

import graph.Graph;
import graph.ShortestPath;
import graph.Graph.Arc;

import java.util.*;

public class Dijkstra<T> implements ShortestPath<T> {

    @Override
    public Distances<T> compute(Graph<T> g, T src, Animator<T> animator) throws IllegalArgumentException {
        // Initialisation des distances et prédécesseurs
        Map<T, Integer> dist = new HashMap<>();
        Map<T, T> pred = new HashMap<>();
        dist.put(src, 0);
        pred.put(src, null);

        // File de priorité pour choisir le sommet avec la plus petite distance
        PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(node -> node.dist));
        pq.add(new Node(src, 0));

        // Ensemble des sommets visités
        Set<T> visited = new HashSet<>();

        // Indique si une valuation négative a été trouvée
        boolean hasNegativeValuation = false;

        while (!pq.isEmpty()) {
            Node current = pq.poll();
            T u = current.node;

            // Si déjà visité, passer
            if (visited.contains(u)) continue;
            visited.add(u);

            // Appeler l'animator pour signaler que la distance est définitive
            animator.accept(u, dist.get(u));

            // Parcourir les successeurs de u
            for (Arc<T> arc : g.getSucc(u)) {
                T v = arc.dst();
                int weight = arc.val();

                // Vérifier si la valuation est négative
                if (weight < 0) {
                    hasNegativeValuation = true;
                    continue; // On continue pour détecter toutes les valuations négatives
                }

                // Si v n'est pas visité, mettre à jour sa distance
                if (!visited.contains(v)) {
                    int newDist = dist.get(u) + weight;
                    Integer oldDist = dist.get(v);

                    if (oldDist == null || newDist < oldDist) {
                        dist.put(v, newDist);
                        pred.put(v, u);
                        pq.add(new Node(v, newDist));
                    }
                }
            }
        }

        // Si une valuation négative a été trouvée, lever une exception
        if (hasNegativeValuation) {
            throw new IllegalArgumentException("Valuation négative détectée dans le graphe.");
        }

        return new Distances<>(dist, pred);
    }

    // Classe interne pour la file de priorité
    private class Node {
        T node;
        int dist;

        Node(T node, int dist) {
            this.node = node;
            this.dist = dist;
        }
    }
}